"""
Service module for generating premium invoice PDFs using WeasyPrint.

This service encapsulates the logic required to render an invoice to an
HTML template and convert it into a PDF document via WeasyPrint.
It relies on Django's template engine to populate the template with
dynamic data and ensures that static assets (such as the company logo)
are resolved correctly through the use of ``base_url``.  Setting
``base_url`` to ``settings.BASE_DIR`` (the root of the project) allows
WeasyPrint to locate static files referenced by absolute paths in
production and development environments.
"""

from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import Tuple

from django.conf import settings
from django.template.loader import render_to_string

# Import WeasyPrint only on demand.  We catch ImportError specifically so that
# other runtime errors (e.g. missing system libraries like Pango) propagate
# normally and provide a more informative error to the user.  Catching
# ``ImportError`` ensures we don't silently mask these issues by
# pretending WeasyPrint is unavailable when it is installed but
# misconfigured.
try:
    from weasyprint import HTML, CSS  # type: ignore
except ImportError:  # pragma: no cover
    HTML = None  # type: ignore
    CSS = None  # type: ignore


@dataclass
class PdfFile:
    """Simple container for PDF bytes and a suggested filename."""

    filename: str
    content: bytes
    mimetype: str = "application/pdf"


class InvoicePdfService:
    """Service responsible for rendering invoice PDFs using WeasyPrint."""

    template_name: str = "pdf/invoice_premium.html"

    def generate(self, invoice) -> PdfFile:
        """Render an invoice to PDF.

        Parameters
        ----------
        invoice: django.db.models.Model
            An instance of the Invoice model containing all data to
            populate the template.  The object should provide fields
            like ``number``, ``issue_date``, ``due_date``, a related
            manager ``invoice_items`` for line items (each with
            ``description``, ``quantity``, ``unit_price``, ``tax_rate``),
            and fields for totals (``total_ht``, ``tva`` and
            ``total_ttc``).

        Returns
        -------
        PdfFile
            A dataclass instance holding the generated bytes and a
            filename computed from the invoice number.
        """
        if HTML is None:
            raise RuntimeError(
                "WeasyPrint must be installed in order to generate PDFs."
            )
        # Assemble branding information
        branding = getattr(settings, "INVOICE_BRANDING", {}) or {}
        # Compute a list of dicts representing each invoice line.
        rows: list = []
        inv_items = getattr(invoice, "invoice_items", None)
        for it in inv_items.all() if inv_items is not None else []:  # type: ignore[attr-defined]
            try:
                qty = getattr(it, "quantity", 0)
                pu = getattr(it, "unit_price", 0)
                # For the premium layout we only need total HT.  TVA and TTC
                # are computed globally below.
                total_ht_line = qty * pu
            except Exception:
                qty = 0
                pu = 0
                total_ht_line = 0
            rows.append({
                "description": getattr(it, "description", ""),
                "quantity": qty,
                "unit_price": pu,
                "total_ht": total_ht_line,
            })
        # Compute overall VAT percentage for display (avoid division by zero).
        total_ht_val = getattr(invoice, "total_ht", 0) or 0
        total_tva_val = getattr(invoice, "tva", 0) or 0
        try:
            if total_ht_val:
                tva_rate = (total_tva_val / total_ht_val) * 100
            else:
                tva_rate = 0
        except Exception:
            tva_rate = 0
        # Extract client information from the invoice's quote if available.
        client_name = ""
        client_address: str | None = None
        client_email = ""
        client_phone = ""
        client_reference = ""
        quote = getattr(invoice, "quote", None)
        client = None
        if quote is not None:
            client = getattr(quote, "client", None)
        if client is not None:
            client_name = getattr(client, "full_name", "") or ""
            # Build a single address string with line breaks if fields exist
            parts: list[str] = []
            street = getattr(client, "address_line", None) or getattr(client, "address", None)
            if street:
                parts.append(str(street))
            zip_code = getattr(client, "zip_code", None)
            city = getattr(client, "city", None)
            # Some systems may store zip and city separately
            if zip_code:
                parts.append(str(zip_code))
            if city:
                parts.append(str(city))
            if parts:
                client_address = "\n".join(parts)
            client_email = getattr(client, "email", "") or ""
            client_phone = getattr(client, "phone", "") or ""
            # Try to fetch a reference code if defined on the client model
            client_reference = getattr(client, "reference", "") or ""
        context = {
            "invoice": invoice,
            "branding": branding,
            "rows": rows,
            "tva_rate": tva_rate,
            "client_name": client_name,
            "client_address": client_address,
            "client_email": client_email,
            "client_phone": client_phone,
            "client_reference": client_reference,
        }
        html_string = render_to_string(self.template_name, context)
        # The base_url argument is critical: it tells WeasyPrint where to
        # resolve absolute URLs.  By pointing to BASE_DIR, any
        # references to files under ``static`` (e.g. a logo) will be
        # located correctly in both local and production environments.
        base_dir = Path(getattr(settings, "BASE_DIR", Path.cwd()))
        base_url = str(base_dir)
        # Compile the PDF.  Optionally, load an external CSS file for
        # extra styling.  If you wish to embed a separate CSS file,
        # ensure its path is resolved relative to BASE_DIR/static/css.
        stylesheets = []
        # Try to locate the CSS file using staticfiles finders (production-ready)
        css_path = None
        try:
            from django.contrib.staticfiles import finders
            css_path = finders.find("css/pdf.css")
        except Exception:
            pass
        # Fallback to STATIC_ROOT if finders don't work
        if not css_path:
            static_root = getattr(settings, "STATIC_ROOT", None)
            if static_root:
                candidate = Path(static_root) / "css" / "pdf.css"
                if candidate.exists():
                    css_path = str(candidate)
        # Final fallback to BASE_DIR/static for development
        if not css_path:
            candidate = base_dir / "static" / "css" / "pdf.css"
            if candidate.exists():
                css_path = str(candidate)
        
        if css_path and CSS is not None:
            stylesheets.append(CSS(filename=str(css_path)))
        pdf_bytes = HTML(string=html_string, base_url=base_url).write_pdf(stylesheets=stylesheets)
        number = getattr(invoice, "number", None) or f"FAC-{getattr(invoice, 'pk', 'X')}"
        filename = f"{number}.pdf"
        return PdfFile(filename=filename, content=pdf_bytes)


class QuotePdfService:
    """Service responsible for rendering quote PDFs.

    The project already provides premium HTML templates for quotes
    under ``templates/pdf/quote.html``. We rely on the existing
    WeasyPrint-based helper (``core.services.pdf_generator``) to render
    the document, which guarantees consistent styling with invoices.
    """

    def generate(self, quote) -> PdfFile:
        # Import locally to avoid circular imports
        from core.services.pdf_generator import render_quote_pdf

        res = render_quote_pdf(quote)
        return PdfFile(filename=res.filename, content=res.content, mimetype=res.mimetype)